# Chapter 02 - 객체 지향

> - 객체지향 구성의 이점과 절차지향과의 차이점
> - 객체의 특징과 의의
> - 객체 지향의 주요 개념(1) - 캡슐화

## 객체 Intro

### 절차지향

- 절차 지향은 **데이터를 중심으로 한 프로시저로 구성**된다.
- 프로그램의 규모가 커지면 함께 수정해야하는 프로시저가 증가하고, 같은 데이터를 프로시저마다 다른 의미로 사용하는 경우가 발생한다.
- 문제점
  - 코드의 수정을 어렵게 만들며, 새로운 기능을 추가하는데 많은 구현 시간(리소스)를 투입하게 만듬.

### 객체지향

- 객체지향은 데이터 및 해당 데이터를 조작하는 프로시저를 객체 단위로 묶어서 프로그램을 구성한다.
- 객체의 데이터가 변경되더라도 해당 객체로만 변화가 집중되고, 다른 객체에는 영향을 주지 않기 때문에 쉽게 변경 가능하다. 이는 변화된 요구사항을 빠르게 반영할 수 있도록 만들어준다.
- 객체 지향의 핵심인 **캡슐화 및 추상화가 적용되지 않는다면** 객체 지향을 지원하는 언어를 사용하더라도 실제 결과물은 객체 지향과 거리가 멀어질 수 있다.

---

## 객체의 의의

- 객체를 정의할때 사용되는 것은 **객체가 제공해야할 기능(operation)**
- 객체는 어떠한 기능을 제공한다는 사실만이 중요하다.
- `interface`: 객체가 제공하는 모든 오퍼레이션 집합, 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙.
- `class`: 실제 객체가 기능을 어떻게 구현하는지에 대해 정의한 것.
- `mesaage`: 객체의 오퍼레이션의 실행을 요청하는 것을 메세지를 보낸다고 표현, Java에서는 method를 호출하는 것이 메세지를 보내는 과정에 해당함.
- 관계도

```txt
+-------------------+
|      인터페이스      |
|   <<Interface>>   |
|   + 메서드1()       |
|   + 메서드2()       |
+-------------------+
          ^
          |
+-------------------+
|       클래스        |
|   + 속성1          |
|   + 메서드1()       |
|   + 메서드2()       |
+-------------------+
          |
          |
+--------------------+
|    객체(instance)   |
|   + 속성1의 값       |
|   + 메서드1() 실행    |
+--------------------+

<UML 다이어그램 설명>
- 클래스: 사각형으로 표현, 속성과 메서드를 포함.
- 객체는 클래스의 인스턴스를 나타내며, 클래스와 연결된 점으로 표현.
- 인터페이스는 점선으로 연결된 사각형으로 표현되며,
클래스가 이 인터페이스를 구현(implements)함을 나타냄.
```

---

## 객체의 책임

- **객체마다 자신만의 책임을 갖는다**. 객체가 갖는 책임을 정의한 것이 타입/인터페이스.
- 객체의 책임 할당 과정
  - 프로그램을 만들기 위해 필요한 기능 목록 정리
  - 기능을 객체별로 책임 분배
    -> **객체가 갖는 책임의 크기가 작을 수록 좋다**. 한 객체에 기능이 많아지면 많은 프로시저가 데이터를 공유해서 사용하여 절차 지향적인 구조를 갖게된다.
  - **단일 책임 원칙(SRP): 객체는 단 한개의 책임만을 가져야 한다는 원칙**
  - 기능의 세부 내용이 변경될 때, 변경해야 할 부분이 한 곳으로 집중된다.

## 객체의 의존

- 의존유형
  1.  한 객체가 다른 객체를 생성
  2.  다른 객체의 메서드를 호출
  3.  파라미터로 다른 객체를 전달받음
- 다른 타입에 의존을 한다는 것은 의존하는 타입에 변경이 발생할 때 함께 변경될 가능성이 높다는것을 의미한다.
- 변경은 의존 관계를 따라 전이되고, 객체 상호간에 영향을 준다.
- **의존 역전 원칙(DIP): 순한 의존이 발생하지 않도록 하는 원칙**
  - 순환 의존은 변경의 여파가 나 자신에게 다시 영향을 줄 수 있다.

---

## 캡슐화(Encapsulation)

> 객체가 내부적으로 기능을 **어떻게 구현하는지**를 감추는 것

- 캡슐화를 통해 한 곳의 변화가 다른 곳에 미치는 영향을 최소화한다.
- 데이터 중심의 프로그램(절차지향)은 변경 사항의 전파가 크지만, 객체지향은 캡슐화를 통해 내부 구현의 변경을 유연하게 한다.
- 캡슐화의 규칙
  - **Tell, Don't Ask**: 데이터를 물어보지 않고, 기능을 실행해달라고 프로그램을 작성
    -> 데이터를 직접 읽는 것은 객체 지향적 프로그래밍을 유도함.
    -> 기능 실행을 요청하는 방식
  - **데미테르의 법칙**
    -> 한 번의 객체 메서드만 호출하면서 데이터 중심이 아닌 기능 중심으로 코드를 작성하도록 유도함.
    -> 연속적인 get메서드 호출 및 임시 변수의 get 호출이 잦다면 데미테르 법칙을 위반했을 확률이 높다.
